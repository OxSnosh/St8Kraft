//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.7;

import "./CountryMinter.sol";
import "./War.sol";
import "./Wonders.sol";
import "./Infrastructure.sol";
import "./Forces.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

contract NukeContract is Ownable, VRFConsumerBaseV2 {
    uint256 nukeAttackId;
    uint256 nukesDroppedToday;
    uint256 nukesDropped1DayAgo;
    uint256 nukesDropped2DaysAgo;
    uint256 nukesDropped3DaysAgo;
    uint256 nukesDropped4DaysAgo;
    uint256 nukesDropped5DaysAgo;
    uint256 nukesDropped6DaysAgo;
    address countryMinter;
    address warAddress;
    address wonders1;
    address improvements3;
    address improvements4;
    address infrastructure;
    address forces;
    address keeper;

    //Chainlik Variables
    uint256[] private s_randomWords;
    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;
    uint64 private immutable i_subscriptionId;
    bytes32 private immutable i_gasLane;
    uint32 private immutable i_callbackGasLimit;
    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant NUM_WORDS = 1;

    CountryMinter mint;
    WarContract war;
    WondersContract1 won1;
    ImprovementsContract3 imp3;
    ImprovementsContract4 imp4;
    InfrastructureContract inf;
    ForcesContract force;

    struct NukeAttack {
        uint256 warId;
        uint256 attackerId;
        uint256 defenderId;
        uint256 attackType;
    }

    mapping(uint256 => NukeAttack) nukeAttackIdToNukeAttack;
    mapping(uint256 => uint256) s_requestIdToRequestIndex;
    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;

    constructor(
        address _countryMinter,
        address _warAddress,
        address _wonders1,
        address _improvements3,
        address _improvements4,
        address vrfCoordinatorV2,
        uint64 subscriptionId,
        bytes32 gasLane, // keyHash
        uint32 callbackGasLimit
    ) VRFConsumerBaseV2(vrfCoordinatorV2) {
        countryMinter = _countryMinter;
        mint = CountryMinter(_countryMinter);
        warAddress = _warAddress;
        war = WarContract(_warAddress);
        wonders1 = _wonders1;
        won1 = WondersContract1(_wonders1);
        improvements3 = _improvements3;
        imp3 = ImprovementsContract3(_improvements3);
        improvements4 = _improvements4;
        imp4 = ImprovementsContract4(_improvements4);
        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);
        i_gasLane = gasLane;
        i_subscriptionId = subscriptionId;
        i_callbackGasLimit = callbackGasLimit;
    }

    function constructorContinued (
        address _infrastructure,
        address _forces,
        address _keeper 
    ) public onlyOwner {
        infrastructure = _infrastructure;
        inf = InfrastructureContract(_infrastructure);
        forces = _forces;
        force = ForcesContract(_forces);
        keeper = _keeper;
    }

    function updateCountryMinterContract(address newAddress) public onlyOwner {
        countryMinter = newAddress;
        mint = CountryMinter(newAddress);
    }

    function updateWarContract(address newAddress) public onlyOwner {
        warAddress = newAddress;
        war = WarContract(newAddress);
    }

    function updateWonders1Contract(address newAddress) public onlyOwner {
        wonders1 = newAddress;
        won1 = WondersContract1(newAddress);
    }

    function launchNuke(
        uint256 warId,
        uint256 attackerId,
        uint256 defenderId,
        uint256 attackType
    ) public {
        bool isOwner = mint.checkOwnership(attackerId, msg.sender);
        require(isOwner, "!nation owner");
        bool isActive = war.isWarActive(warId);
        require(isActive, "war not active");
        (uint256 offenseId, uint256 defenseId) = war.getInvolvedParties(warId);
        require(
            attackerId == offenseId || attackerId == defenseId,
            "attacker not involved in this war"
        );
        require(
            defenderId == offenseId || defenderId == defenseId,
            "defender not involved in this war"
        );
        uint256 daysLeft = war.getDaysLeft(warId);
        require(daysLeft < 6, "not at war long enough to launch a nuke");
        bool emp = won1.getEmpWeaponization(attackerId);
        if (!emp) {
            require(
                attackType == 1,
                "can only launch a standard attack without emp"
            );
        } else {
            require(attackType <= 4, "invalid attack type");
        }
        NukeAttack memory newAttack = NukeAttack(
            warId,
            attackerId,
            defenderId,
            attackType
        );
        nukeAttackIdToNukeAttack[nukeAttackId] = newAttack;
        fulfillRequest(nukeAttackId);
        nukeAttackId++;
    }

    function fulfillRequest(uint256 id) public {
        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_gasLane,
            i_subscriptionId,
            REQUEST_CONFIRMATIONS,
            i_callbackGasLimit,
            NUM_WORDS
        );
        s_requestIdToRequestIndex[requestId] = id;
    }

    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)
        internal
        override
    {
        uint256 requestNumber = s_requestIdToRequestIndex[requestId];
        s_requestIndexToRandomWords[requestNumber] = randomWords;
        s_randomWords = randomWords;
        uint256 attackerId = nukeAttackIdToNukeAttack[requestNumber].attackerId;
        uint256 defenderId = nukeAttackIdToNukeAttack[requestNumber].defenderId;
        uint256 defenderMissileDefenses = imp4.getMissileDefenseCount(
            defenderId
        );
        uint256 attackerSattelites = imp3.getSatelliteCount(attackerId);
        uint256 thwartOdds = 60;
        if (defenderMissileDefenses > 0) {
            thwartOdds += (defenderMissileDefenses * 5);
        }
        if (attackerSattelites > 0) {
            thwartOdds -= (attackerSattelites * 5);
        }
        uint256 randomNukeSuccessNumber = ((s_randomWords[0] % 100) + 1);
        if (randomNukeSuccessNumber > thwartOdds) {
            inflictNukeDamage(requestNumber);
        } else {
            //thwart event
        }
    }

    function inflictNukeDamage(uint256 attackId) internal {
        uint256 attackType = nukeAttackIdToNukeAttack[attackId].attackType;
        if (attackType == 1) {
            standardAttack(attackId);
        } else if (attackType == 2) {
            infrastructureAttack(attackId);
        } else if (attackType == 3) {
            landAttack(attackId);
        } else if (attackType == 4) {
            technologyAttack(attackId);
        }
    }

    function standardAttack(uint256 attackId) internal {
        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;
        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;
        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);
        force.decreaseDefendingTankCountFromNukeContract(defenderId);
        inf.decreaseLandCountFromNukeContract(defenderId);
        inf.decreaseInfrastructureCountFromNukeContract(defenderId, attackerId);
        inf.decreaseTechCountFromNukeContract(defenderId);
    }

    function infrastructureAttack(uint256 attackId) internal {
        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;
        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;
        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);
        force.decreaseDefendingTankCountFromNukeContract(defenderId);
        inf.decreaseLandCountFromNukeContract(defenderId);
        inf.decreaseInfrastructureCountFromNukeContract(defenderId, attackerId);
        inf.decreaseTechCountFromNukeContract(defenderId);
    }

    function landAttack(uint256 attackId) internal {
        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;
        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;
        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);
        force.decreaseDefendingTankCountFromNukeContract(defenderId);
        inf.decreaseLandCountFromNukeContract(defenderId);
        inf.decreaseInfrastructureCountFromNukeContract(defenderId, attackerId);
        inf.decreaseTechCountFromNukeContract(defenderId);
    }

    function technologyAttack(uint256 attackId) internal {
        uint256 defenderId = nukeAttackIdToNukeAttack[attackId].defenderId;
        uint256 attackerId = nukeAttackIdToNukeAttack[attackId].attackerId;
        force.decreaseDefendingSoldierCountFromNukeAttack(defenderId);
        force.decreaseDefendingTankCountFromNukeContract(defenderId);
        inf.decreaseLandCountFromNukeContract(defenderId);
        inf.decreaseInfrastructureCountFromNukeContract(defenderId, attackerId);
        inf.decreaseTechCountFromNukeContract(defenderId);
    }

    function calculateNukesLandedLastSevenDays() public view returns (uint256) {
        uint256 sum = (nukesDroppedToday +
            nukesDropped1DayAgo +
            nukesDropped2DaysAgo +
            nukesDropped3DaysAgo +
            nukesDropped4DaysAgo +
            nukesDropped5DaysAgo +
            nukesDropped6DaysAgo);
        return sum;
    }

    function getGlobalRadiation() public view returns (uint256) {
        uint256 countries = mint.getCountryCount();
        uint256 nukesLanded = calculateNukesLandedLastSevenDays();
        uint256 mod = 300;
        uint256 globalRadiation = ((nukesLanded * mod) / countries);
        return globalRadiation;
    }

    modifier onlyKeeper() {
        require (msg.sender == keeper, "only callable from keeper");
        _;
    }

    //called by keeper
    function shiftNukesDroppedDays() public onlyKeeper {
        nukesDropped6DaysAgo = nukesDropped5DaysAgo;
        nukesDropped5DaysAgo = nukesDropped4DaysAgo;
        nukesDropped4DaysAgo = nukesDropped3DaysAgo;
        nukesDropped3DaysAgo = nukesDropped2DaysAgo;
        nukesDropped2DaysAgo = nukesDropped1DayAgo;
        nukesDroppedToday = 0;
    }
}
